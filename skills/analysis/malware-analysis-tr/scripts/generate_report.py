#!/usr/bin/env python3
"""
Malware Data Collector

Collects all analysis data into a structured format for Claude to analyze.
Claude performs the reasoning and writes the analyst-grade report.

Usage:
    python3 generate_report.py /path/to/sample.exe -f json
    python3 generate_report.py /path/to/sample.exe -f text
"""

import argparse
import json
import sys
from datetime import datetime, timezone
from pathlib import Path

# Import sibling modules
script_dir = Path(__file__).parent
sys.path.insert(0, str(script_dir))

from static_analysis import analyze_file
from triage import MalwareTriage
from extract_iocs import extract_from_file


def collect_analysis_data(
    filepath: str,
    skip_triage: bool = False,
    vt_key: str = None,
    abuseipdb_key: str = None,
    abusech_key: str = None,
) -> dict:
    """Collect all analysis data into a structured dict."""
    
    path = Path(filepath)
    if not path.exists():
        return {"error": f"File not found: {filepath}"}
    
    data = {
        "sample": {
            "filepath": str(path.absolute()),
            "filename": path.name,
            "analysis_time": datetime.now(timezone.utc).isoformat(),
        },
        "static_analysis": None,
        "threat_intelligence": None,
        "extracted_iocs": None,
    }
    
    # Static analysis
    print("[*] Running static analysis...", file=sys.stderr)
    static_results = analyze_file(filepath)
    if "error" not in static_results:
        data["static_analysis"] = static_results
    else:
        data["static_analysis"] = {"error": static_results["error"]}
    
    # Threat intelligence
    if not skip_triage:
        print("[*] Querying threat intelligence...", file=sys.stderr)
        triage = MalwareTriage(
            vt_key=vt_key, 
            abuseipdb_key=abuseipdb_key, 
            abusech_key=abusech_key,
            verbose=True
        )
        data["threat_intelligence"] = triage.triage_file(filepath)
    else:
        data["threat_intelligence"] = {"skipped": True}
    
    # IOC extraction
    print("[*] Extracting IOCs...", file=sys.stderr)
    data["extracted_iocs"] = extract_from_file(filepath, defang=True)
    
    return data


def format_as_text(data: dict) -> str:
    """Format collected data as readable text for Claude to analyze."""
    
    lines = []
    lines.append("=" * 70)
    lines.append("MALWARE ANALYSIS DATA COLLECTION")
    lines.append("=" * 70)
    lines.append("")
    
    # Sample info
    sample = data.get("sample", {})
    lines.append(f"Sample: {sample.get('filename', 'unknown')}")
    lines.append(f"Analysis Time: {sample.get('analysis_time', 'unknown')}")
    lines.append("")
    
    # Static analysis
    lines.append("-" * 70)
    lines.append("STATIC ANALYSIS")
    lines.append("-" * 70)
    
    static = data.get("static_analysis", {})
    if static.get("error"):
        lines.append(f"Error: {static['error']}")
    else:
        # Hashes
        hashes = static.get("hashes", {})
        lines.append(f"MD5:    {hashes.get('md5', 'N/A')}")
        lines.append(f"SHA1:   {hashes.get('sha1', 'N/A')}")
        lines.append(f"SHA256: {hashes.get('sha256', 'N/A')}")
        lines.append("")
        
        # File info
        file_info = static.get("file", {})
        lines.append(f"File Type: {file_info.get('type', 'unknown')}")
        lines.append(f"File Size: {file_info.get('size', 0):,} bytes")
        lines.append("")
        
        # PE analysis
        pe = static.get("pe_analysis", {})
        if pe:
            lines.append(f"Architecture: {pe.get('architecture', 'N/A')} ({pe.get('type', '')})")
            lines.append(f"Compile Time: {pe.get('compile_timestamp', 'N/A')}")
            lines.append(f"Overall Entropy: {pe.get('entropy', 0):.4f}")
            lines.append("")
            
            # Sections
            sections = pe.get("sections", [])
            if sections:
                lines.append("PE Sections:")
                for s in sections:
                    lines.append(f"  {s.get('name', '?'):10} entropy={s.get('entropy', 0):.2f}  chars={s.get('characteristics', '')}")
            lines.append("")
        
        # Suspicious indicators
        suspicious = static.get("suspicious_indicators", {})
        
        apis = suspicious.get("suspicious_apis", [])
        if apis:
            lines.append(f"Suspicious APIs ({len(apis)}):")
            for api in apis:
                lines.append(f"  - {api}")
            lines.append("")
        
        urls = suspicious.get("urls", [])
        if urls:
            lines.append(f"URLs in strings ({len(urls)}):")
            for url in urls[:10]:
                lines.append(f"  - {url}")
            if len(urls) > 10:
                lines.append(f"  ... and {len(urls) - 10} more")
            lines.append("")
        
        ips = suspicious.get("ip_addresses", [])
        if ips:
            lines.append(f"IP Addresses ({len(ips)}):")
            for ip in ips[:10]:
                lines.append(f"  - {ip}")
            lines.append("")
        
        registry = suspicious.get("registry_keys", [])
        if registry:
            lines.append(f"Registry Keys ({len(registry)}):")
            for key in registry[:5]:
                lines.append(f"  - {key}")
            lines.append("")
    
    # Threat Intelligence
    lines.append("-" * 70)
    lines.append("THREAT INTELLIGENCE")
    lines.append("-" * 70)
    
    ti = data.get("threat_intelligence", {})
    if ti.get("skipped"):
        lines.append("Skipped (offline mode)")
    else:
        verdict = ti.get("verdict", "unknown")
        lines.append(f"Overall Verdict: {verdict.upper()}")
        lines.append("")
        
        summary = ti.get("summary", {})
        if summary.get("malware_families"):
            lines.append(f"Malware Families: {', '.join(summary['malware_families'])}")
        if summary.get("virustotal_detection"):
            lines.append(f"VT Detection: {summary['virustotal_detection']}")
        lines.append("")
        
        # Source details
        for source in ti.get("sources", []):
            src_name = source.get("source", "unknown").upper()
            if source.get("error"):
                lines.append(f"{src_name}: Error - {source['error']}")
            elif source.get("found"):
                lines.append(f"{src_name}: FOUND")
                if source.get("signature"):
                    lines.append(f"  Family: {source['signature']}")
                if source.get("detection_rate"):
                    lines.append(f"  Detection: {source['detection_rate']}")
                if source.get("popular_threat_names"):
                    lines.append(f"  Threat: {source['popular_threat_names']}")
                if source.get("first_seen"):
                    lines.append(f"  First Seen: {source['first_seen']}")
                if source.get("tags"):
                    lines.append(f"  Tags: {', '.join(source['tags'][:5])}")
            else:
                lines.append(f"{src_name}: Not found")
            lines.append("")
    
    # Extracted IOCs
    lines.append("-" * 70)
    lines.append("EXTRACTED IOCs")
    lines.append("-" * 70)
    
    iocs = data.get("extracted_iocs", {})
    for ioc_type, values in iocs.items():
        if values:
            lines.append(f"{ioc_type} ({len(values)}):")
            for v in values[:5]:
                lines.append(f"  - {v}")
            if len(values) > 5:
                lines.append(f"  ... and {len(values) - 5} more")
            lines.append("")
    
    lines.append("=" * 70)
    lines.append("END OF DATA COLLECTION")
    lines.append("=" * 70)
    
    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(
        description="Collect malware analysis data for Claude to analyze",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
This script collects data. Claude performs the analysis and reasoning.

Examples:
  %(prog)s sample.exe -f text     # Human-readable output
  %(prog)s sample.exe -f json     # Structured JSON
  %(prog)s sample.exe --skip-triage  # Offline mode
        """
    )
    parser.add_argument("file", help="Path to malware sample")
    parser.add_argument("-f", "--format", choices=["text", "json"], default="text",
                        help="Output format (default: text)")
    parser.add_argument("-o", "--output", help="Output file (default: stdout)")
    parser.add_argument("--skip-triage", action="store_true", help="Skip TI lookups")
    parser.add_argument("--abusech-key", help="abuse.ch Auth-Key")
    parser.add_argument("--vt-key", help="VirusTotal API key")
    parser.add_argument("--abuseipdb-key", help="AbuseIPDB API key")
    
    args = parser.parse_args()
    
    data = collect_analysis_data(
        filepath=args.file,
        skip_triage=args.skip_triage,
        vt_key=args.vt_key,
        abuseipdb_key=args.abuseipdb_key,
        abusech_key=args.abusech_key,
    )
    
    if args.format == "json":
        output = json.dumps(data, indent=2, default=str)
    else:
        output = format_as_text(data)
    
    if args.output:
        Path(args.output).write_text(output)
        print(f"Data written to {args.output}", file=sys.stderr)
    else:
        print(output)


if __name__ == "__main__":
    main()
