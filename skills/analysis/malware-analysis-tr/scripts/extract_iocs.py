#!/usr/bin/env python3
"""
IOC (Indicators of Compromise) extraction and formatting tool.
Extracts, deduplicates, and defangs IOCs from files or text input.
"""

import argparse
import hashlib
import re
import sys
from pathlib import Path
from typing import TextIO


# IOC regex patterns
PATTERNS = {
    "ipv4": r'\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b',
    "ipv6": r'\b(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}\b|\b(?:[0-9a-fA-F]{1,4}:){1,7}:\b|\b(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}\b',
    "domain": r'\b(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+(?:com|net|org|io|info|biz|co|us|uk|de|ru|cn|xyz|top|site|online|club|app|dev|tech|shop|pro|me|tv|cc|pw|tk|ml|ga|cf|gq|onion|bit)\b',
    "url": r'https?://[^\s<>"{}|\\^`\[\]]+',
    "email": r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
    "md5": r'\b[a-fA-F0-9]{32}\b',
    "sha1": r'\b[a-fA-F0-9]{40}\b',
    "sha256": r'\b[a-fA-F0-9]{64}\b',
    "sha512": r'\b[a-fA-F0-9]{128}\b',
    "cve": r'CVE-\d{4}-\d{4,}',
    "registry": r'(?:HKEY_(?:LOCAL_MACHINE|CURRENT_USER|CLASSES_ROOT|USERS|CURRENT_CONFIG)|HKLM|HKCU|HKCR|HKU|HKCC)\\[^\s"\'<>]+',
    "filepath_windows": r'[A-Za-z]:\\(?:[^\s<>"|?*\\]+\\)*[^\s<>"|?*\\]+',
    "filepath_unix": r'(?:/(?:usr|etc|var|tmp|home|opt|bin|sbin|lib|root|dev|proc|sys)/[^\s<>"]+)',
    "btc_wallet": r'\b[13][a-km-zA-HJ-NP-Z1-9]{25,34}\b',
    "eth_wallet": r'\b0x[a-fA-F0-9]{40}\b',
    "xmr_wallet": r'\b4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}\b',
    "useragent": r'Mozilla/5\.0[^"\'<>\n]+',
    "mutex": r'(?:Global\\|Local\\)[^\s"\'<>]+',
}

# Common false positive patterns to filter
FALSE_POSITIVES = {
    "ipv4": {"0.0.0.0", "127.0.0.1", "255.255.255.255", "192.168.0.1", "192.168.1.1", "10.0.0.1"},
    "domain": {"example.com", "test.com", "localhost.com", "domain.com"},
    "md5": set(),  # Will filter hex strings that are too uniform
    "sha1": set(),
    "sha256": set(),
}


def is_false_positive_hash(hash_str: str) -> bool:
    """Check if a hash is likely a false positive (too uniform)."""
    unique_chars = len(set(hash_str.lower()))
    return unique_chars < 4  # Filter out strings like "0000...0000" or "aaaa...aaaa"


def defang_ip(ip: str) -> str:
    """Defang IP address: 192.168.1.1 -> 192[.]168[.]1[.]1"""
    return ip.replace(".", "[.]")


def defang_url(url: str) -> str:
    """Defang URL: http://evil.com -> hxxp://evil[.]com"""
    result = url.replace("http://", "hxxp://").replace("https://", "hxxps://")
    # Defang domain part
    result = re.sub(r'(?<=://)([^/]+)', lambda m: m.group(1).replace(".", "[.]"), result)
    return result


def defang_domain(domain: str) -> str:
    """Defang domain: evil.com -> evil[.]com"""
    return domain.replace(".", "[.]")


def defang_email(email: str) -> str:
    """Defang email: bad@evil.com -> bad[@]evil[.]com"""
    return email.replace("@", "[@]").replace(".", "[.]")


def refang(text: str) -> str:
    """Refang IOCs in text (reverse defanging)."""
    result = text
    result = result.replace("[.]", ".")
    result = result.replace("[@]", "@")
    result = result.replace("hxxp://", "http://")
    result = result.replace("hxxps://", "https://")
    result = result.replace("[:]", ":")
    return result


def extract_iocs(text: str, defang: bool = True, include_types: list = None) -> dict:
    """
    Extract IOCs from text.
    
    Args:
        text: Input text to extract IOCs from
        defang: Whether to defang IOCs (default True)
        include_types: List of IOC types to include (default: all)
    
    Returns:
        Dictionary of IOC type -> list of unique IOCs
    """
    results = {}
    
    types_to_extract = include_types if include_types else list(PATTERNS.keys())
    
    for ioc_type in types_to_extract:
        if ioc_type not in PATTERNS:
            continue
            
        pattern = PATTERNS[ioc_type]
        matches = set(re.findall(pattern, text, re.IGNORECASE if ioc_type not in ["md5", "sha1", "sha256", "sha512"] else 0))
        
        # Filter false positives
        fp_set = FALSE_POSITIVES.get(ioc_type, set())
        matches = {m for m in matches if m.lower() not in {fp.lower() for fp in fp_set}}
        
        # Filter uniform hashes
        if ioc_type in ["md5", "sha1", "sha256", "sha512"]:
            matches = {m for m in matches if not is_false_positive_hash(m)}
        
        # Filter private IPs if extracting IPs
        if ioc_type == "ipv4":
            public_only = set()
            for ip in matches:
                octets = ip.split(".")
                # Skip private ranges
                if octets[0] == "10":
                    continue
                if octets[0] == "172" and 16 <= int(octets[1]) <= 31:
                    continue
                if octets[0] == "192" and octets[1] == "168":
                    continue
                if octets[0] == "169" and octets[1] == "254":
                    continue
                public_only.add(ip)
            matches = public_only
        
        if matches:
            # Apply defanging
            if defang:
                if ioc_type == "ipv4" or ioc_type == "ipv6":
                    matches = {defang_ip(m) for m in matches}
                elif ioc_type == "url":
                    matches = {defang_url(m) for m in matches}
                elif ioc_type == "domain":
                    matches = {defang_domain(m) for m in matches}
                elif ioc_type == "email":
                    matches = {defang_email(m) for m in matches}
            
            results[ioc_type] = sorted(matches)
    
    return results


def format_output(iocs: dict, format_type: str = "text", include_stats: bool = True) -> str:
    """Format IOCs for output."""
    
    if format_type == "json":
        import json
        output = {
            "iocs": iocs,
        }
        if include_stats:
            output["statistics"] = {ioc_type: len(values) for ioc_type, values in iocs.items()}
            output["total"] = sum(len(v) for v in iocs.values())
        return json.dumps(output, indent=2)
    
    elif format_type == "csv":
        lines = ["type,value"]
        for ioc_type, values in iocs.items():
            for value in values:
                # Escape quotes in CSV
                escaped = value.replace('"', '""')
                lines.append(f'{ioc_type},"{escaped}"')
        return "\n".join(lines)
    
    elif format_type == "stix":
        # Simplified STIX-like output
        indicators = []
        for ioc_type, values in iocs.items():
            for value in values:
                indicators.append({
                    "type": "indicator",
                    "pattern_type": ioc_type,
                    "pattern": value,
                })
        import json
        return json.dumps({"type": "bundle", "objects": indicators}, indent=2)
    
    else:  # text format
        lines = []
        lines.append("=" * 60)
        lines.append("EXTRACTED INDICATORS OF COMPROMISE")
        lines.append("=" * 60)
        
        total = 0
        for ioc_type, values in sorted(iocs.items()):
            if values:
                type_display = ioc_type.upper().replace("_", " ")
                lines.append(f"\n[{type_display}] ({len(values)} found)")
                lines.append("-" * 40)
                for value in values:
                    lines.append(f"  {value}")
                total += len(values)
        
        if include_stats:
            lines.append("\n" + "=" * 60)
            lines.append(f"TOTAL IOCs EXTRACTED: {total}")
            lines.append("=" * 60)
        
        return "\n".join(lines)


def extract_from_file(filepath: str, defang: bool = True) -> dict:
    """Extract IOCs from a file (binary or text)."""
    path = Path(filepath)
    
    if not path.exists():
        raise FileNotFoundError(f"File not found: {filepath}")
    
    # Try to read as text first
    try:
        text = path.read_text(encoding='utf-8', errors='ignore')
    except Exception:
        # Fall back to binary read and decode
        data = path.read_bytes()
        text = data.decode('utf-8', errors='ignore')
        # Also try to extract ASCII strings from binary
        ascii_strings = re.findall(rb'[\x20-\x7e]{4,}', data)
        text += " " + " ".join(s.decode('ascii', errors='ignore') for s in ascii_strings)
    
    return extract_iocs(text, defang=defang)


def main():
    parser = argparse.ArgumentParser(description="Extract and defang IOCs from files or stdin")
    parser.add_argument("input", nargs="?", help="Input file (reads stdin if not provided)")
    parser.add_argument("-f", "--format", choices=["text", "json", "csv", "stix"], default="text",
                        help="Output format (default: text)")
    parser.add_argument("-o", "--output", help="Output file (default: stdout)")
    parser.add_argument("--no-defang", action="store_true", help="Don't defang IOCs")
    parser.add_argument("--refang", action="store_true", help="Refang IOCs in input (reverse defanging)")
    parser.add_argument("-t", "--types", nargs="+", choices=list(PATTERNS.keys()),
                        help="Only extract specific IOC types")
    parser.add_argument("--list-types", action="store_true", help="List available IOC types")
    
    args = parser.parse_args()
    
    if args.list_types:
        print("Available IOC types:")
        for ioc_type in sorted(PATTERNS.keys()):
            print(f"  - {ioc_type}")
        return
    
    # Read input
    if args.input:
        if args.refang:
            text = Path(args.input).read_text()
            text = refang(text)
            iocs = extract_iocs(text, defang=not args.no_defang, include_types=args.types)
        else:
            iocs = extract_from_file(args.input, defang=not args.no_defang)
            if args.types:
                iocs = {k: v for k, v in iocs.items() if k in args.types}
    else:
        text = sys.stdin.read()
        if args.refang:
            text = refang(text)
        iocs = extract_iocs(text, defang=not args.no_defang, include_types=args.types)
    
    # Format output
    output = format_output(iocs, args.format)
    
    if args.output:
        Path(args.output).write_text(output)
        print(f"Results written to {args.output}", file=sys.stderr)
    else:
        print(output)


if __name__ == "__main__":
    main()
